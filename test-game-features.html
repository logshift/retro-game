<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Game Feature Tests</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            padding: 20px;
            max-width: 800px;
            margin: 0 auto;
        }
        .test-section {
            margin: 20px 0;
            padding: 15px;
            border: 2px solid #ddd;
            border-radius: 5px;
        }
        .test-section h2 {
            margin-top: 0;
            color: #663399;
        }
        .test-result {
            padding: 10px;
            margin: 5px 0;
            border-radius: 3px;
        }
        .pass {
            background-color: #d4edda;
            color: #155724;
        }
        .fail {
            background-color: #f8d7da;
            color: #721c24;
        }
        button {
            background-color: #663399;
            color: white;
            border: none;
            padding: 10px 20px;
            margin: 5px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
        }
        button:hover {
            background-color: #8B5FBF;
        }
        .info {
            background-color: #d1ecf1;
            padding: 10px;
            border-radius: 3px;
            margin: 10px 0;
        }
    </style>
</head>
<body>
    <h1>Flappy Taylors - Feature Test Suite</h1>
    
    <div class="test-section">
        <h2>Score Persistence Tests</h2>
        <div id="score-tests"></div>
        <button onclick="runScorePersistenceTests()">Run Score Tests</button>
        <button onclick="clearHighScore()">Clear High Score</button>
    </div>
    
    <div class="test-section">
        <h2>Particle System Tests</h2>
        <div id="particle-tests"></div>
        <button onclick="runParticleTests()">Run Particle Tests</button>
    </div>
    
    <div class="test-section">
        <h2>Edge Case Tests</h2>
        <div id="edge-tests"></div>
        <button onclick="runEdgeCaseTests()">Run Edge Case Tests</button>
    </div>
    
    <div class="test-section">
        <h2>Manual Testing Instructions</h2>
        <div class="info">
            <h3>Visual Tests (perform manually):</h3>
            <ol>
                <li><strong>Trail Effect:</strong> Start game and observe purple trail particles following Kiro</li>
                <li><strong>Sparkle Effect:</strong> Pass through obstacles and observe sparkle particles</li>
                <li><strong>Explosion Effect:</strong> Collide with obstacle/ground and observe explosion particles</li>
                <li><strong>Confetti Effect:</strong> Beat your high score and observe confetti falling from top</li>
                <li><strong>High Score Display:</strong> Check game over screen shows both current and high score</li>
                <li><strong>Performance:</strong> Play for extended time and verify smooth frame rate</li>
            </ol>
        </div>
        <button onclick="window.open('index.html', '_blank')">Open Game</button>
    </div>

    <script>
        // Score Persistence Tests
        function runScorePersistenceTests() {
            const output = document.getElementById('score-tests');
            output.innerHTML = '';
            
            // Test 1: Empty storage initialization
            localStorage.removeItem('flappyTaylorsHighScore');
            const ScoreManager = {
                highScore: 0,
                storageKey: 'flappyTaylorsHighScore',
                
                loadHighScore() {
                    try {
                        const stored = localStorage.getItem(this.storageKey);
                        if (stored === null || stored === undefined) {
                            this.highScore = 0;
                            return 0;
                        }
                        const parsed = parseInt(stored, 10);
                        if (isNaN(parsed) || parsed < 0) {
                            this.highScore = 0;
                            this.saveHighScore(0);
                            return 0;
                        }
                        this.highScore = parsed;
                        return parsed;
                    } catch (e) {
                        this.highScore = 0;
                        return 0;
                    }
                },
                
                saveHighScore(score) {
                    try {
                        localStorage.setItem(this.storageKey, score.toString());
                        this.highScore = score;
                    } catch (e) {
                        console.warn('Failed to save high score:', e);
                    }
                },
                
                checkAndUpdateHighScore(currentScore) {
                    if (currentScore > this.highScore) {
                        this.saveHighScore(currentScore);
                        return true;
                    }
                    return false;
                }
            };
            
            let result = ScoreManager.loadHighScore();
            addResult(output, 'Empty storage initializes to 0', result === 0);
            
            // Test 2: Save and retrieve score
            ScoreManager.saveHighScore(42);
            result = ScoreManager.loadHighScore();
            addResult(output, 'Save and retrieve score (42)', result === 42);
            
            // Test 3: Update high score when exceeded
            ScoreManager.highScore = 42;
            let isNew = ScoreManager.checkAndUpdateHighScore(50);
            addResult(output, 'Update high score when exceeded (50 > 42)', isNew === true && ScoreManager.highScore === 50);
            
            // Test 4: Don't update when not exceeded
            ScoreManager.highScore = 50;
            isNew = ScoreManager.checkAndUpdateHighScore(30);
            addResult(output, 'Don\'t update when not exceeded (30 < 50)', isNew === false && ScoreManager.highScore === 50);
            
            // Test 5: Corrupted data handling
            localStorage.setItem('flappyTaylorsHighScore', 'invalid');
            result = ScoreManager.loadHighScore();
            addResult(output, 'Handle corrupted data', result === 0);
            
            // Test 6: Negative score handling
            localStorage.setItem('flappyTaylorsHighScore', '-10');
            result = ScoreManager.loadHighScore();
            addResult(output, 'Handle negative score', result === 0);
            
            // Test 7: Round trip persistence
            ScoreManager.saveHighScore(100);
            const stored = localStorage.getItem('flappyTaylorsHighScore');
            addResult(output, 'Round trip persistence (100)', stored === '100');
        }
        
        // Particle System Tests
        function runParticleTests() {
            const output = document.getElementById('particle-tests');
            output.innerHTML = '';
            
            class Particle {
                constructor(x, y, vx, vy, life, size, color, type) {
                    this.x = x;
                    this.y = y;
                    this.vx = vx;
                    this.vy = vy;
                    this.life = life;
                    this.maxLife = life;
                    this.size = size;
                    this.color = color;
                    this.type = type;
                    this.rotation = 0;
                    this.rotationSpeed = 0;
                }
            }
            
            const ParticleManager = {
                particles: [],
                maxParticles: 500,
                
                createTrail(x, y) {
                    const colors = ['#663399', '#8B5FBF', '#9370DB'];
                    const color = colors[Math.floor(Math.random() * colors.length)];
                    const particle = new Particle(x, y, -1.5, 0, 30, 4, color, 'trail');
                    this.particles.push(particle);
                },
                
                createExplosion(x, y) {
                    const particleCount = 15 + Math.floor(Math.random() * 6);
                    const colors = ['#FF4136', '#FF851B', '#FFDC00', '#FF6B6B', '#FFA500'];
                    for (let i = 0; i < particleCount; i++) {
                        const angle = (Math.PI * 2 * i) / particleCount;
                        const speed = 2 + Math.random() * 3;
                        const color = colors[Math.floor(Math.random() * colors.length)];
                        const particle = new Particle(x, y, Math.cos(angle) * speed, Math.sin(angle) * speed, 40, 6, color, 'explosion');
                        this.particles.push(particle);
                    }
                },
                
                createSparkles(x, y) {
                    const particleCount = 8 + Math.floor(Math.random() * 5);
                    const colors = ['#FFFFFF', '#FFFF00', '#FF69B4', '#FF8C00', '#00FF00'];
                    for (let i = 0; i < particleCount; i++) {
                        const angle = Math.random() * Math.PI * 2;
                        const speed = 1 + Math.random() * 2;
                        const color = colors[Math.floor(Math.random() * colors.length)];
                        const particle = new Particle(x, y, Math.cos(angle) * speed, Math.sin(angle) * speed, 20, 6, color, 'sparkle');
                        this.particles.push(particle);
                    }
                },
                
                createConfetti() {
                    const particleCount = 30 + Math.floor(Math.random() * 11);
                    const colors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#FFA07A', '#98D8C8', '#F7DC6F', '#BB8FCE', '#85C1E2'];
                    for (let i = 0; i < particleCount; i++) {
                        const x = Math.random() * 400;
                        const color = colors[Math.floor(Math.random() * colors.length)];
                        const particle = new Particle(x, -10, (Math.random() - 0.5) * 2, Math.random() * 2 + 1, 100, 8, color, 'confetti');
                        particle.rotation = Math.random() * Math.PI * 2;
                        particle.rotationSpeed = (Math.random() - 0.5) * 0.2;
                        this.particles.push(particle);
                    }
                },
                
                update() {
                    for (let p of this.particles) {
                        p.x += p.vx;
                        p.y += p.vy;
                        if (p.type === 'explosion') p.vy += 0.15;
                        if (p.type === 'confetti') p.vy += 0.1;
                        p.life -= 1 / p.maxLife;
                        if (p.type === 'confetti') p.rotation += p.rotationSpeed;
                    }
                    this.particles = this.particles.filter(p => {
                        if (p.life <= 0) return false;
                        if (p.type === 'confetti' && p.y > 600) return false;
                        return true;
                    });
                    if (this.particles.length > this.maxParticles) {
                        this.particles = this.particles.slice(this.particles.length - this.maxParticles);
                    }
                }
            };
            
            // Test 1: Trail particle creation
            ParticleManager.particles = [];
            ParticleManager.createTrail(100, 100);
            addResult(output, 'Trail particle created', ParticleManager.particles.length === 1 && ParticleManager.particles[0].type === 'trail');
            
            // Test 2: Explosion creates multiple particles
            ParticleManager.particles = [];
            ParticleManager.createExplosion(100, 100);
            const explosionCount = ParticleManager.particles.length;
            addResult(output, 'Explosion creates 15-20 particles', explosionCount >= 15 && explosionCount <= 20);
            
            // Test 3: Sparkles create multiple particles
            ParticleManager.particles = [];
            ParticleManager.createSparkles(100, 100);
            const sparkleCount = ParticleManager.particles.length;
            addResult(output, 'Sparkles create 8-12 particles', sparkleCount >= 8 && sparkleCount <= 12);
            
            // Test 4: Confetti creates multiple particles
            ParticleManager.particles = [];
            ParticleManager.createConfetti();
            const confettiCount = ParticleManager.particles.length;
            addResult(output, 'Confetti creates 30-40 particles', confettiCount >= 30 && confettiCount <= 40);
            
            // Test 5: Confetti has rotation
            const confettiParticle = ParticleManager.particles[0];
            addResult(output, 'Confetti has rotation properties', confettiParticle.rotation !== undefined && confettiParticle.rotationSpeed !== undefined);
            
            // Test 6: Particle life decreases
            ParticleManager.particles = [];
            ParticleManager.createTrail(100, 100);
            const initialLife = ParticleManager.particles[0].life;
            ParticleManager.update();
            const updatedLife = ParticleManager.particles[0].life;
            addResult(output, 'Particle life decreases on update', updatedLife < initialLife);
            
            // Test 7: Dead particles removed
            ParticleManager.particles = [];
            const deadParticle = new Particle(100, 100, 0, 0, 0, 5, '#FF0000', 'trail');
            deadParticle.life = 0;
            ParticleManager.particles.push(deadParticle);
            ParticleManager.update();
            addResult(output, 'Dead particles removed (life = 0)', ParticleManager.particles.length === 0);
            
            // Test 8: Off-screen confetti removed
            ParticleManager.particles = [];
            const offscreenConfetti = new Particle(100, 700, 0, 0, 50, 5, '#FF0000', 'confetti');
            ParticleManager.particles.push(offscreenConfetti);
            ParticleManager.update();
            addResult(output, 'Off-screen confetti removed (y > 600)', ParticleManager.particles.length === 0);
            
            // Test 9: Max particle limit enforced
            ParticleManager.particles = [];
            for (let i = 0; i < 600; i++) {
                ParticleManager.particles.push(new Particle(0, 0, 0, 0, 100, 5, '#FF0000', 'trail'));
            }
            ParticleManager.update();
            addResult(output, 'Max particle limit enforced (500)', ParticleManager.particles.length === 500);
            
            // Test 10: Explosion particles radiate outward
            ParticleManager.particles = [];
            ParticleManager.createExplosion(100, 100);
            let hasVariedVelocities = false;
            const velocities = ParticleManager.particles.map(p => ({ vx: p.vx, vy: p.vy }));
            for (let i = 1; i < velocities.length; i++) {
                if (velocities[i].vx !== velocities[0].vx || velocities[i].vy !== velocities[0].vy) {
                    hasVariedVelocities = true;
                    break;
                }
            }
            addResult(output, 'Explosion particles have varied velocities', hasVariedVelocities);
        }
        
        // Edge Case Tests
        function runEdgeCaseTests() {
            const output = document.getElementById('edge-tests');
            output.innerHTML = '';
            
            // Test 1: First game with no high score
            localStorage.removeItem('flappyTaylorsHighScore');
            const stored = localStorage.getItem('flappyTaylorsHighScore');
            addResult(output, 'First game scenario (no stored score)', stored === null);
            
            // Test 2: Rapid score increases
            const ScoreManager = {
                highScore: 0,
                storageKey: 'flappyTaylorsHighScore',
                saveHighScore(score) {
                    localStorage.setItem(this.storageKey, score.toString());
                    this.highScore = score;
                },
                checkAndUpdateHighScore(currentScore) {
                    if (currentScore > this.highScore) {
                        this.saveHighScore(currentScore);
                        return true;
                    }
                    return false;
                }
            };
            
            ScoreManager.highScore = 0;
            let newHighScoreCount = 0;
            for (let i = 1; i <= 10; i++) {
                if (ScoreManager.checkAndUpdateHighScore(i)) {
                    newHighScoreCount++;
                }
            }
            addResult(output, 'Rapid score increases handled (10 updates)', newHighScoreCount === 10 && ScoreManager.highScore === 10);
            
            // Test 3: Very high score values
            ScoreManager.saveHighScore(999999);
            const highScore = parseInt(localStorage.getItem('flappyTaylorsHighScore'), 10);
            addResult(output, 'Very high score values (999999)', highScore === 999999);
            
            // Test 4: Zero score handling
            ScoreManager.saveHighScore(0);
            const zeroScore = parseInt(localStorage.getItem('flappyTaylorsHighScore'), 10);
            addResult(output, 'Zero score handling', zeroScore === 0);
            
            // Test 5: Multiple confetti colors
            const colors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#FFA07A', '#98D8C8', '#F7DC6F', '#BB8FCE', '#85C1E2'];
            const uniqueColors = new Set();
            for (let i = 0; i < 40; i++) {
                const color = colors[Math.floor(Math.random() * colors.length)];
                uniqueColors.add(color);
            }
            addResult(output, 'Confetti uses multiple colors (>= 3)', uniqueColors.size >= 3);
            
            addResult(output, '✓ All edge case tests completed', true);
        }
        
        function clearHighScore() {
            localStorage.removeItem('flappyTaylorsHighScore');
            alert('High score cleared! Reload the game to test first-time behavior.');
        }
        
        function addResult(container, testName, passed) {
            const div = document.createElement('div');
            div.className = `test-result ${passed ? 'pass' : 'fail'}`;
            div.textContent = `${passed ? '✓' : '✗'} ${testName}`;
            container.appendChild(div);
        }
    </script>
</body>
</html>
